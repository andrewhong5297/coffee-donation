If you're building a web app, you'll need a connect wallet button. We like using the family connectkit library for this (https://family.co/docs/connectkit/getting-started) which uses wagmi/viem under the hood.

Here is how to setup connect kit:

\`\`\`typescript
import { WagmiProvider, createConfig, http } from "wagmi";
import { mainnet } from "wagmi/chains";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { ConnectKitProvider, getDefaultConfig } from "connectkit";

const config = createConfig(
  getDefaultConfig({
    // Your dApps chains
    chains: [mainnet],
    transports: {
      // RPC URL for each chain
      [mainnet.id]: http(
        \`https://eth-mainnet.g.alchemy.com/v2/\${process.env.NEXT_PUBLIC_ALCHEMY_ID}\`,
      ),
    },

    // Required API Keys
    walletConnectProjectId: process.env.NEXT_PUBLIC_WALLETCONNECT_PROJECT_ID, //you can set this to anything, it doesn't matter if you only want desktop wallet connections. To get a key you can go to https://reown.com/blog/walletconnect-is-now-reown

    // Required App Info
    appName: "Your App Name",

    // Optional App Info
    appDescription: "Your App Description",
    appUrl: "https://family.co", // your app's url
    appIcon: "https://family.co/logo.png", // your app's icon, no bigger than 1024x1024px (max. 1MB)
  }),
);

const queryClient = new QueryClient();

export const Web3Provider = ({ children }) => {
  return (
    <WagmiProvider config={config}>
      <QueryClientProvider client={queryClient}>
        <ConnectKitProvider>{children}</ConnectKitProvider>
      </QueryClientProvider>
    </WagmiProvider>
  );
};
\`\`\`

And then placing it in the app:

\`\`\`typescript
import { Web3Provider } from "./Web3Provider";
import { ConnectKitButton } from "connectkit";

const App = () => {
  return (
    <Web3Provider>
      <ConnectKitButton />
    </Web3Provider>
  );
};
\`\`\`

Do NOT create dummy transaction hashes when the user submits in the app, you should always send the transaction to the wallet to be submitted onchain. Here is a working example for sending a transaction and execution that you can copy:

\`\`\`typescript
  import { useAccount, useSendTransaction, useSwitchChain } from 'wagmi'
  import { base } from "wagmi/chains";

  ...in component code...
  const { address, isConnected } = useAccount()
  const { switchChain } = useSwitchChain();

  //switch to the correct chain id for the trail
  useEffect(() => {
    switchChain({ chainId: base.id });
  }, [switchChain, address]);

  // You can use the useSendTransaction hook from wagmi (https://wagmi.sh/react/api/hooks/useSendTransaction).
  const { sendTransaction, isPending, error: txError } = useSendTransaction({
    mutation: {
      onSuccess: async (hash: string) => {
        console.log('Transaction successfully sent:', hash)
        try {
          // After confirming the transaction, send the transaction hash back to the executions API
          await fetch(
            \`${apiBaseUrl}/v1/trails/:trailId/versions/:versionId/executions/:walletAddress/wallet\`,
            {
              method: "POST",
              body: JSON.stringify({ nodeId: primaryNodeId, transactionHash: hash, walletAddress: address!, executionType: "latest" }),
            },
          );
        } catch (err) {
          console.error('Failed to submit execution:', err)
        }
      },
      onError: (error: Error) => {
        console.error('Transaction failed:', error)
      }
    }
  })

  //where this goes in an onClick handler in the UI
  const handleSubmit = async (someInputArgsFromFrontend) => {
    // get the call arguments from the evaluations API
    const evaluation = await apiCallToGetEvaluationData(someInputArgsFromFrontend)

    // create transaction request
    const transactionRequest: {
      from: \`0x\${string}\`,
      to: \`0x\${string}\`,
      data: \`0x\${string}\`,
      value: bigint,
    } = {
      from: address as \`0x\${string}\`,
      to: evaluation.finalContractAddress as \`0x\${string}\`,
      data: evaluation.callData as \`0x\${string}\`,
      value: BigInt(evaluation.finalPayableAmount ?? "0"),
    }

    // send transaction onchain - success/error handling is done in the useSendTransaction callbacks
    sendTransaction(transactionRequest)
  }
\`\`\`
